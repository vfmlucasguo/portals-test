//
//  PortalsPlugin.swift
//  Plugin
//
//  Created by Steven Sherry on 5/19/22.
//  Copyright Â© 2022 Max Lynch. All rights reserved.
//

import Foundation
import Capacitor
import IonicLiveUpdates

@objc(CAPPortalsPlugin)
class PortalsPlugin: CAPPlugin {
    private let decoder = JSONDecoder()
    private let encoder = JSONEncoder()

    var portals: Portals?

    override init(bridge: CAPBridgeProtocol, pluginId: String, pluginName: String) {
        super.init(bridge: bridge, pluginId: pluginId, pluginName: pluginName)
    }

    override func load() {
        let decoder = JSONDecoder()

        guard let shellObject = getConfigValue("shell") as? JSObject,
              let appsArray = getConfigValue("apps") as? [JSObject],
              let shell = try? decoder.decodeJSObject(Portal.self, from: shellObject),
              let apps = try? appsArray
                .map({ try decoder.decodeJSObject(Portal.self, from: $0) })
                .reduce(into: [:], { acc, next in
                    acc[next.name] = next
                })
        else { fatalError("Check your portals configuration") }

        let portals = Portals(shell: shell, apps: apps)
        self.portals = portals

        register(portals)
    }

    @objc func reload(_ call: CAPPluginCall) {
        guard let vc = bridge?.viewController as? PortalsViewController else { return }
        DispatchQueue.main.async {
            vc.reload()
            call.resolve()
        }
    }

    @objc func syncOne(_ call: CAPPluginCall) {
        guard let appId = call.getString("appId") else {
            return call.resolve([
                "failStep": LiveUpdateManager.Error.FailStep.check.rawValue.uppercased(),
                "message": "Live Update failed because appId was not provided"
            ])
        }

        LiveUpdateManager.shared.sync(appId: appId) { result in
            switch result {
            case .success(let liveUpdate):
                let jsObject = try? self.encoder.encodeJSObject(liveUpdate)
                call.resolve(jsObject ?? [:])

            case .failure(let error):
                let jsObject: JSObject = [
                    "appId": appId,
                    "failStep": error.failStep.rawValue.uppercased(),
                    "message": error.localizedDescription
                ]

                call.resolve(jsObject)
            }
        }
    }

    @objc func syncSome(_ call: CAPPluginCall) {
        guard let appIds = call.getArray("appIds", String.self), !appIds.isEmpty else {
            return call.resolve([
                "failStep": LiveUpdateManager.Error.FailStep.check.rawValue.uppercased(),
                "message": "Live Update appIds was either empty or not a valid array of strings"
            ])
        }

        call.keepAlive = true

        LiveUpdateManager.shared.sync(appIds: appIds) {
            call.resolve(["complete": true])
            self.bridge?.releaseCall(call)
        } appComplete: { result in
            self.appComplete(result: result, call: call)
        }
    }

    @objc func syncAll(_ call: CAPPluginCall) {
        call.keepAlive = true
        LiveUpdateManager.shared.sync {
            call.resolve(["complete": true])
            self.bridge?.releaseCall(call)
        } appComplete: { result in
            self.appComplete(result: result, call: call)
        }
    }

    private func appComplete(result: Result<LiveUpdate, LiveUpdateManager.Error>, call: CAPPluginCall) {
        switch result {
        case .success(let liveUpdate):
            let jsObject = try? self.encoder.encodeJSObject(liveUpdate)
            call.resolve(jsObject ?? [:])

        case .failure(let error):
            let jsObject: JSObject = [
                "appId": error.appId,
                "failStep": error.failStep.rawValue.uppercased(),
                "message": error.localizedDescription
            ]

            call.resolve(jsObject)
        }
    }

    private func register(_ portals: Portals) {
        let liveUpdateConfigs = portals.apps
            .reduce(into: [portals.shell]) { acc, next in
                acc.append(next.value)
            }
            .compactMap { $0.liveUpdateConfig }

        if liveUpdateConfigs.isEmpty { return }

        let liveUpdates = liveUpdateConfigs.map { config in
            LiveUpdate(
                appId: config.appId,
                channel: config.channel,
                syncOnAdd: false
            )
        }

        try? liveUpdates.forEach(LiveUpdateManager.shared.add)

        let appIdsToUpdate = liveUpdateConfigs
            .filter { $0.autoUpdateMethod == .background }
            .map { $0.appId }

        LiveUpdateManager.shared.sync(appIds: appIdsToUpdate)
    }
}

extension JSONDecoder {
    func decodeJSObject<T: Decodable>(_ type: T.Type, from object: JSObject) throws -> T {
        let data = try JSONSerialization.data(withJSONObject: object)
        return try decode(T.self, from: data)
    }
}

extension JSONEncoder {
    func encodeJSObject<T: Encodable>(_ value: T) throws -> JSObject {
        let data = try encode(value)
        let dictionary = try JSONSerialization.jsonObject(with: data) as? NSDictionary
        return JSTypes.coerceDictionaryToJSObject(dictionary)!
    }
}
